#!/usr/bin/env python3
import tf2_ros
import tf2_geometry_msgs # Crucial to import
from sensor_msgs.msg import JointState
import time
import rospy
import moveit_commander
import actionlib
import numpy as np
from tf import transformations as T

from pddlstream.algorithms.meta import solve # type: ignore
from pddlstream.utils import read # type: ignore
from pddlstream.language.generator import from_fn, from_list_fn, from_gen_fn # type: ignore
from pddlstream.language.constants import PDDLProblem # type: ignore

from primitives import Conf
from stream import get_arm_motion_gen, get_grasp_gen, get_ik_fn, get_base_motion_gen, GRASPS
from tmc_control_msgs.msg import GripperApplyEffortAction, GripperApplyEffortGoal
from geometry_msgs.msg import PoseStamped, Pose
from control_msgs.msg import GripperCommandAction, GripperCommandGoal
from gazebo_msgs.srv import GetModelState
import hsrb_interface

GRASP_FORCE = 0.2
HAND_TF = "hand_palm_link"


def add_object(scene, object_name):
    rospy.wait_for_service("/gazebo/get_model_state")
    get_state = rospy.ServiceProxy("/gazebo/get_model_state", GetModelState)
    state = get_state(object_name, "")

    pose = state.pose
    pose.position.z = pose.position.z + 0.105

    pose_stamped = PoseStamped()
    pose_stamped.header.frame_id = "map"
    pose_stamped.header.stamp = rospy.Time.now()
    pose_stamped.pose = pose

    if object_name == "ycb_003_cracker_box":
        # quaternion = (
        #     pose.orientation.x,
        #     pose.orientation.y,
        #     pose.orientation.z,
        #     pose.orientation.w,
        # )
        # euler = T.euler_from_quaternion(quaternion)
        # rotated_euler = (euler[0], euler[1], euler[2] + np.pi / 2)
        # rotated_quaternion = T.quaternion_from_euler(*rotated_euler)
        # pose.orientation.x = rotated_quaternion[0]
        # pose.orientation.y = rotated_quaternion[1]
        # pose.orientation.z = rotated_quaternion[2]
        # pose.orientation.w = rotated_quaternion[3]
        dimensions = (0.06, 0.16, 0.21)
    elif object_name == "kitchen_table":
        table_height = 0.68
        pose_stamped.pose.position.z = table_height / 2
        dimensions = (0.68, 1.13, table_height)
        # pose.position.z = 0.68
        # dimensions = (0.68, 1.13, 0.04)
    else:
        dimensions = (0.1, 0.1, 0.1)
    # if object_name == 'kitchen_table':
    #     breakpoint()
    #     scene.add_mesh(
    #         object_name,
    #         pose_stamped,
    #         "/opt/ros/noetic/share/tmc_gazebo_worlds/models/kitchen_table/model-1_4.sdf",
    #     )
    # else:
    scene.add_box(object_name, pose_stamped, dimensions)
    rospy.sleep(1.0)


def init_robot_state():
    # Create publisher for joint states
    joint_state_pub = rospy.Publisher('/hsrb/joint_states', JointState, queue_size=10)
    
    # Create initial joint state message
    joint_state = JointState()
    joint_state.name = [
        'wrist_ft_sensor_frame_joint',
        'base_b_bumper_joint',
        'base_f_bumper_joint',
        'base_l_passive_wheel_x_frame_joint',
        'base_l_passive_wheel_y_frame_joint',
        'base_l_passive_wheel_z_joint',
        'base_r_passive_wheel_x_frame_joint',
        'base_r_passive_wheel_y_frame_joint',
        'base_r_passive_wheel_z_joint'
    ]
    joint_state.position = [0.0] * len(joint_state.name)
    
    # Publish a few times to ensure state is received
    rate = rospy.Rate(10)
    for _ in range(10):
        joint_state.header.stamp = rospy.Time.now()
        joint_state_pub.publish(joint_state)
        rate.sleep()

def main():
    rospy.init_node("tamp")
    hsrb_robot = hsrb_interface.Robot()
    hsrb_gripper = hsrb_robot.get('gripper')
    hsrb_whole_body = hsrb_robot.get('whole_body')
    # init_robot_state()
    while not rospy.is_shutdown():
        try:
            arm_group = moveit_commander.MoveGroupCommander("arm", wait_for_servers=0.0)
            whole_body = moveit_commander.MoveGroupCommander("whole_body", wait_for_servers=0.0)
            # base_group = moveit_commander.MoveGroupCommander("base", wait_for_servers=0.0)
            arm_group.set_pose_reference_frame("base_link")
            whole_body.set_pose_reference_frame("map")
            # base_group.set_pose_reference_frame("map")
            scene = moveit_commander.PlanningSceneInterface()

            whole_body.allow_replanning(True)
            whole_body.set_planning_time(10)
            whole_body.set_max_velocity_scaling_factor(0.7)
            end_effector = whole_body.get_end_effector_link()
            
            break
        except RuntimeError as e:
            print("Failed to launch, retrying ", e)
            rospy.sleep(1.0)

    robot_state = moveit_commander.RobotState()
    joint_state = rospy.wait_for_message("/hsrb/joint_states", JointState, timeout=1.0)
    robot_state.joint_state = joint_state
    whole_body.set_start_state(robot_state)
    get_state = rospy.ServiceProxy("/gazebo/get_model_state", GetModelState)
    breakpoint()

    # Create problem instance and robot command interface

    arm_joints = [
        "arm_lift_joint",
        "arm_flex_joint",
        "arm_roll_joint",
        "wrist_flex_joint",
        "wrist_roll_joint",
        "wrist_ft_sensor_frame_joint",
    ]
    base_joint = "world_joint"
    # Get current arm configuration for start
    current_joints = arm_group.get_current_joint_values()
    start_arm_conf = Conf(arm_group, arm_joints, current_joints)

    start_base_values = [0,0,0]
    start_base_conf = Conf(whole_body, [base_joint], start_base_values)

    object_name = "ycb_003_cracker_box"
    # object_name = 'ycb_014_lemon'
    add_object(scene, object_name)
    add_object(scene, 'kitchen_table')
    if object_name in scene.get_known_object_names():
        object_pose_dict = scene.get_object_poses([object_name])
        object_pose = Pose()
        object_pose.position = object_pose_dict[object_name].position
        object_pose.orientation = object_pose_dict[object_name].orientation
    else:
        rospy.loginfo("Object not found in scene")
        return

    base_motion_gen = get_base_motion_gen(whole_body, robot_state)
    arm_motion_gen = get_arm_motion_gen(whole_body, robot_state)
    grasp_gen = get_grasp_gen(whole_body, scene, robot_state)
    ik_fn = get_ik_fn(whole_body, arm_group, robot_state)

    domain_pddl = read(
        "/home/rchome/workspaces/raghav_ws/src/villa_tamp/src/pddl/pick_place_domain.pddl"
    )
    stream_pddl = read(
        "/home/rchome/workspaces/raghav_ws/src/villa_tamp/src/pddl/pick_place_stream.pddl"
    )

    init = [
        # Arm
        ("Arm", "arm"),
        ("ArmConf", start_arm_conf),
        ("AtArmConf", "arm", start_arm_conf),
        ("HandEmpty",),

        # Base
        ("BConf", start_base_conf),
        ("AtBConf", start_base_conf),

        # Receptacle
        ("Table", "kitchen_table"),

        # Object
        ("Object", object_name),
        ("Pose", object_name, object_pose),
        ("AtPose", object_name, object_pose),
        ("Graspable", object_name),
        ("OnTable", object_name, "kitchen_table"),
        ("Clear", object_name),
    ]
    goal = ("Holding", object_name)

    stream_map = {
        "plan-base-motion": from_fn(base_motion_gen),
        "plan-arm-motion": from_fn(arm_motion_gen),
        "sample-grasp": from_list_fn(grasp_gen),
        "inverse-kinematics": from_gen_fn(ik_fn),
    }

    whole_body.set_support_surface_name("kitchen_table")
    # Create and solve problem
    pddl_problem = PDDLProblem(domain_pddl, {}, stream_pddl, stream_map, init, goal)
    solution = solve(pddl_problem)
    if solution is None:
        rospy.loginfo("No solution found")
        return

    # Execute the solution
    plan, cost, evaluations = solution
    if plan is None:
        rospy.loginfo("Failed to find a plan")
        return
    
    rospy.loginfo("Executing the plan: %s", plan)
    for i, (name, args) in enumerate(plan):
        rospy.loginfo("Step %d: %s %s", i, name, args)
        
        if name == "move_base":
            q1, t, q2 = args
            # Set final target
            trajectory = t.commands[0]
            if trajectory.moveit_plan is not None:
                rospy.loginfo("Executing move base plan")
                whole_body.execute(trajectory.moveit_plan)
            else:
                joint_values = [
                    q2.values[0],  # x
                    q2.values[1],  # y
                    q2.values[2],  # theta
                ]
                whole_body.set_joint_value_target("world_joint", joint_values)
                success = whole_body.go(wait=True)
                if not success:
                    rospy.logwarn("Failed to execute the plan")
                    return

        elif name == "move_arm":
            a, q1, t, q2 = args

            trajectory = t.commands[0]
            if trajectory.moveit_plan is not None:
                rospy.loginfo("Executing move arm plan")
                arm_group.execute(trajectory.moveit_plan)
            else:
                # Set initial target
                joint_values = [
                    q1.values[0],  # x
                    q1.values[1],  # y
                    q1.values[2],  # theta
                ]
                arm_group.set_joint_value_target("world_joint", joint_values)
                success = arm_group.go(wait=True)
                if not success:
                    rospy.logwarn("Failed to execute the plan")
                    return

        elif name == "pick":
            _, obj, pose, grasp, q, bq = args
            import moveit_msgs.msg
            n_attempts = 0
            result=None
            while (result != moveit_msgs.msg.MoveItErrorCodes.SUCCESS) and (n_attempts < 2):
                n_attempts += 1
                rospy.loginfo("Pick attempt: " + str(n_attempts))
                for grasp in GRASPS:
                    result = whole_body.pick(obj, grasp)
                    if result == moveit_msgs.msg.MoveItErrorCodes.SUCCESS:
                        break
                    else:
                        print(result)
                    rospy.sleep(0.2)
            if hasattr(bq, 'moveit_plan') and bq.moveit_plan is not None:
                rospy.loginfo("Executing move base plan of the pick action")
                whole_body.execute(bq.moveit_plan)
                rospy.sleep(0.5)
            # else:
            #     joint_values = [
            #         bq.values[0],  # x
            #         bq.values[1],  # y
            #         bq.values[2],  # theta
            #     ]
            #     whole_body.set_joint_value_target("world_joint", joint_values)
            #     success = whole_body.go(wait=True)
            #     if not success:
            #         rospy.logwarn("Failed to move base for pick")
            #         return
            if hasattr(q, 'moveit_plan') and q.moveit_plan is not None:
                rospy.loginfo("Executing move arm plan of the pick action")
                whole_body.execute(q.moveit_plan)
                rospy.sleep(0.5)
            
            # try:
            #     # try using hsrb interface
            #     hsrb_gripper.command(1.0)
            #     rospy.sleep(1.0)
            #     hsrb_gripper.apply_force(GRASP_FORCE)
            #     rospy.sleep(2.0)
            # except Exception as e:
            #     rospy.logwarn("Failed to grasp the object using hsrb interface")
            #     gripper = GripperController()
        
    
        else:
            import pdb; pdb.set_trace()


if __name__ == "__main__":
    main()
